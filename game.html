<!doctype html>
<html>
<head>
	<link href="https://fonts.googleapis.com/css?family=VT323" rel="stylesheet">
	<style type="text/css">
		body{
			image-rendering: pixelated;
			image-rendering: -moz-crisp-edges;
			image-rendering: crisp-edges;
			background-color: #000;
		}
		#gameMargin{
			position: absolute;
			top:0;
			left:0;
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}

		div.gameLayer{
			position: absolute;
			top: 0;
			left: 0;
			margin: auto;
			width: 100%;
			height: 100%;
		}

		#overlay{
			font-size: 50px;
			font-family: 'VT323', monospace;
		}

	</style>
	<script type="text/javascript" src="keyboard.js"></script>
	<script type="text/javascript" src="generator.js"></script> 
	<script type="text/javascript" src="elementSprite.js"></script>
	<script type="text/javascript" src="jquery.min.js"></script>
	<script type="text/javascript">
		var motionControls = {};
		var playerSpriteSet = new spriteSet();
		var player;
		var gameScale = 5, cellSize = 12;
		var sprites = {};
		var maps = Array();
		var activeMap;
		var mapLayer;
		var gameInterval; // <-- the animation interval object
		var walkSpeed = 3;
		var angSpeedRatio = {
			x : .70711,
			y : .70711

			/*
			// these old values were used on an isometric map
			x : 0.866, // <- sin(pi / 3)
			y : 0.5 // <- cos(pi / 3)
			*/
		};
		var screenMiddle = {x: 0, y : 0};

		var player = (function(){
			var position = {x : 0, y : 0};
			return {
				direction : 'down',
				sprite : null,
				'position' : position,
				mapPos : function(x, y){
					if(x == undefined) x = this.position.x;
					if(y == undefined) y = this.position.y;
					return {
						x : Math.floor((x + 2 + screenMiddle.x) / cellSize),
						y : Math.floor((y - 2 + screenMiddle.y) / cellSize) + 1
					}
				},
				setMapPos : function(x, y){
					this.position.x = cellSize * x - screenMiddle.x;
					this.position.y = cellSize * y - screenMiddle.y;
				},
				canWalkOn : function(x, y){
					var map = activeMap.map;
					var rval = true;
					var pos = this.mapPos(x, y);
					if(pos.x < 0 || pos.y < 0 || pos >= map.length || pos.y >= map[pos.x].length){
						rval = false;
					}else if({'#' : 1}[map[pos.x][pos.y]] != undefined){
						rval = false;
					}
					return rval;
				},
				currentMapVal : function(){
					var map = activeMap.map;
					var rval;
					var pos = this.mapPos();
					if(pos.x < 0 || pos.y < 0 || pos.x >= map.length || pos.y >= map[pos.x].length){
						rval = null;
					}else{
						rval = map[pos.x][pos.y];
					}
					return rval;


				},
				currentItems : function(){
					rval = Array();
					var pos = this.mapPos();
					if(activeMap.mappedItems[pos.x] != undefined){
						if(activeMap.mappedItems[pos.x][pos.y] != undefined){
							for(var n in activeMap.mappedItems[pos.x][pos.y]){
								rval = rval.concat(activeMap.mappedItems[pos.x][pos.y]);
							}
						}
					}
					return rval;


				},
				move : function(dx, dy, noCollision){
					var i, xTally, yTally;
					var sgndx = Math.sign(dx);
					var absdx = Math.abs(dx);
					var sgndy = Math.sign(dy);
					var absdy = Math.abs(dy);
					

					if (absdx >= absdy){
						yTally = absdx >> 1;
						for(i = 0; i < absdx; i++){
							yTally += absdy;
							if (yTally >= absdx){
								yTally -= absdx;
								if(this.canWalkOn(this.position.x, this.position.y + sgndy)){
									this.position.y += sgndy;
								}
							}
							if(this.canWalkOn(this.position.x + sgndx, this.position.y)){
								this.position.x += sgndx;
							}
						}
					}else{
						xTally = absdy >> 1;
						for(i = 0; i < absdy; i++){
							xTally += absdx;
							if(xTally >= absdy){
								xTally -= absdy;
								if(this.canWalkOn(this.position.x + sgndx, this.position.y)){
									this.position.x += sgndx;
								}
							}
							if(this.canWalkOn(this.position.x, this.position.y + sgndy)){
								this.position.y += sgndy;
							}
						}
					}
					var pos = this.mapPos();
					alignLayersToPlayer();
				},
				currentSequence: null,
				currentEndFrame : null
			};
		})();

		function renderArea(area){
			var stoneSprite = new spriteClass(sprites.stone);
			stoneSprite.setScale(gameScale);

			var groundSprite = new spriteClass(sprites.ground);
			groundSprite.setScale(gameScale);

			dungeonElementsSprite = new spriteClass(sprites.dungeonElements);
			dungeonElementsSprite.setScale(gameScale);

			var x, y, drawX, drawY, n;
			for(x = 0; x < area.map.length; x++){
				for(y = 0; y < area.map[x].length; y++){
					drawX = x * cellSize * gameScale;
					drawY = y * cellSize * gameScale;

					switch(area.map[x][y]){
						case '.':
							groundSprite.rotate(Math.PI / 2);
							groundSprite.drawRandomArea(mapLayer, drawX, drawY, cellSize, cellSize);
							break;
							break;
						case '#':
							stoneSprite.drawFrame(mapLayer, Math.floor(Math.random() * 25), drawX, drawY);
							break;
						default:
							continue;
					}
				}
			}

			for(var itemName in area.items){
				item = area.items[itemName];
				drawX = item.x * cellSize * gameScale;
				drawY = item.y * cellSize * gameScale;
				switch(item.content){
					case 'stairup':
						dungeonElementsSprite.drawFrame(unitsLayer, 'stairsUp', drawX, drawY);
						break;
					case 'stairdown':
						dungeonElementsSprite.drawFrame(unitsLayer, 'stairsDown', drawX, drawY);
						break;
				}
				//debugger;
			}

			player.setMapPos(area.playerPos.x, area.playerPos.y);
			alignLayersToPlayer();
		}

		function alignLayersToPlayer(){
			$('#mapLayer').css({'top' : -player.position.y * gameScale + 'px', 'left': -player.position.x * gameScale + 'px'});
			$('#unitsLayer').css({'top' : -player.position.y * gameScale + 'px', 'left': -player.position.x * gameScale + 'px'});
		}

		function writeText(x, y, text){
			$('<span></span>').html(text).css({position:'absolute', 'top': (y + gameScale), 'left': (x + gameScale), 'color' : '#000'}).appendTo($('#overlay'));
			$('<span></span>').html(text).css({position:'absolute', 'top': y, 'left': x, 'color' : '#AAA'}).appendTo($('#overlay'));
		}

		function playGame(){
			check_key_state();
			if(player.currentSequence != null){
				switch(player.currentSequence){
					case 'walkup': player.move(0, -walkSpeed); break;
					case 'walkdown': player.move(0, walkSpeed); break;
					case 'walkleft': player.move(-walkSpeed, 0); break;
					case 'walkright': player.move(walkSpeed, 0); break;
					case 'walkupleft': player.move(-angSpeedRatio.x * walkSpeed, -angSpeedRatio.y * walkSpeed ); break;
					case 'walkupright': player.move(angSpeedRatio.x * walkSpeed, -angSpeedRatio.y * walkSpeed ); break;
					case 'walkdownleft': player.move(-angSpeedRatio.x * walkSpeed, angSpeedRatio.y * walkSpeed); break;
					case 'walkdownright': player.move(angSpeedRatio.x * walkSpeed, angSpeedRatio.y * walkSpeed); break;
				}
				player.sprite.doSequenceStep();


			}
		}

		function loadDefaultMotionControls(){
			motionControls = {
				up : [KEYMAP['UP']],
				down: [KEYMAP['DOWN']],
				left: [KEYMAP['LEFT']],
				right: [KEYMAP['RIGHT']],
				enter : [KEYMAP['SHIFT'], KEYMAP['.']],
				exit : [KEYMAP['SHIFT'], KEYMAP[',']],
				attack: [KEYMAP['CTRL']],
				grab : [KEYMAP[',']],
			};
		}

		function checkKeyControl(action){
			var rval, n;
			if(motionControls[action] != undefined){
				rval = true;
				for(n in motionControls[action]){
					rval &= keyState[motionControls[action][n]] ? true : false;
				}
			}else{
				rval = false;
			}
			return rval;
		}
		
		function check_key_state(){
			var dirCombo = 0, n;
			var sequence = null;
			var endFrame = null;
			var fighting = checkKeyControl('attack');

			dirCombo += checkKeyControl('up') ? 1 : 0;
			dirCombo += checkKeyControl('down') ? 2 : 0;
			dirCombo += checkKeyControl('left') ? 4 : 0;
			dirCombo += checkKeyControl('right') ? 8 : 0;
	
			switch(dirCombo){
				case 1: // up
					sequence = 'walkup';
					endFrame = 'back_idle';
					player.direction = 'up';
					break;
				case 2: // down
					sequence = 'walkdown';
					endFrame = 'front_idle';
					player.direction = 'down';
					break;
				case 4: // left
					sequence = 'walkleft';
					endFrame = 'left_idle';
					player.direction = 'left';
					break;
				case 8: // right
					sequence = 'walkright';
					endFrame = 'right_idle';
					player.direction = 'right';
					break;
				case 5: // up/left
					sequence = 'walkupleft';
					endFrame = 'back_left_idle';
					player.direction = 'upleft';
					break;
				case 6: // down/left
					sequence = 'walkdownleft';
					endFrame = 'front_left_idle';
					player.direction = 'downleft';
					break;
				case 9: // up/right
					sequence = 'walkupright';
					endFrame = 'back_right_idle';
					player.direction = 'upright';
					break;
				case 10: // down/right
					sequence = 'walkdownright';
					endFrame = 'front_right_idle';
					player.direction = 'downright';
					break;
			}

			if(fighting){
				var endState = {
					'up' : 'back_idle',
					'down' : 'front_idle',
					'left' : 'left_idle',
					'right' : 'right_idle',
					'upleft' : 'back_left_idle',
					'upright' : 'back_right_idle',
					'downleft' : 'front_left_idle',
					'downright' : 'front_right_idle'
				}[player.direction];
				var newSequence = {
					'up' : 'attack_back',
					'down' : 'attack_front',
					'left' : 'attack_left',
					'right' : 'attack_right',
					'upleft' : 'attack_up_left',
					'upright' : 'attack_up_right',
					'downleft' : 'attack_down_left',
					'downright' : 'attack_down_right'
				}[player.direction];
				if(newSequence != undefined && newSequence != player.currentSequence){
					player.currentSequence = newSequence;
					player.sprite.startSequence(newSequence, {
						iterations: 1,
						method : 'manual',
						callback: function(){
							player.currentSequence = null;
							player.sprite.setFrame(endState);
						}
					});
				}
			}else{
				var currentCellType = player.currentMapVal();
				var currentItems = player.currentItems();

				if(sequence == null){
					if(player.currentSequence != null){
						player.sprite.stopSequence(player.currentSequence);
						player.sprite.setFrame(player.currentEndFrame);
						player.currentSequence = null;
					}
					// this should be replaced with a call to a function that builds a menu of
					// actions available (e.g, "go down", "take food", "take weapon", etc.).  That
					// would be a mildly translucent menu that lits on another interface layer
					// above, perhaps to the bottom right of the player.  Each option in there
					// would have a keyboard shortcut(e.g. "pick up item [,]").  With an option not
					// to display those menus.
					for(n in currentItems){
						switch(currentItems[n].content){
							case 'stairup':
								if(checkKeyControl('exit')){
									var mapIdx = maps.length;
									maps[mapIdx] = new mapBuilder();
									maps[mapIdx].buildDungeon({
										width : 30,
										height: 30,
										roomscale: .8,
										stairup: true,
										stairdown: true
									});
									activeMap = maps[mapIdx];
									document.getElementById("mapLayer").innerHTML = '';
									document.getElementById("unitsLayer").innerHTML = '';
									document.getElementById("overlay").innerHTML = '';
									activeMap.playerPos = {
										x : activeMap.items['stairdown'].x,
										y : activeMap.items['stairdown'].y
									};
									renderArea(activeMap);
								}
								break;
							case 'stairdown':
								if(checkKeyControl('enter')){
									var mapIdx = maps.length;
									maps[mapIdx] = new mapBuilder();
									maps[mapIdx].buildDungeon({
										width : 30,
										height: 30,
										roomscale: .8,
										stairup: true,
										stairdown: true
									});
									activeMap = maps[mapIdx];
									document.getElementById("mapLayer").innerHTML = '';
									document.getElementById("unitsLayer").innerHTML = '';
									document.getElementById("overlay").innerHTML = '';
									activeMap.playerPos = {
										x : activeMap.items['stairup'].x,
										y : activeMap.items['stairup'].y
									};
									renderArea(activeMap);
								}
								break;
							default:
								console.log(currentItems[n].content);
						}
					}

					// there's no walking or fighting going on, let's check theresta
/*					
					if(currentCellType == '>' && checkKeyControl('enter')){
						console.log('going down');
					}
					if(currentCellType == '<' && checkKeyControl('exit')){
						console.log('going up');
					}

*/
				}else if(sequence != player.currentSequence){
					if(player.currentSequence != null){
						player.sprite.stopSequence(player.currentSequence);
					}
					player.currentEndFrame = endFrame;
					player.currentSequence = sequence;
					player.sprite.startSequence(sequence, {
						iterations: 0,
						method : 'manual',
						callback: function(){
							player.currentSequence = null;
							player.sprite.setFrame(endFrame);
						}
					});
				}
			}
		}

		function initialize(step){
			// pre-load any data we need to get the game started.
			// Note that using callbacks on this method prevents it from building a stack.
			// It also allows us to wait for each step to complete before calling the next
			// one.
			if(step == undefined) step = 'initialize';
			switch(step){
				case 'initialize':
					mapLayer = document.getElementById('mapLayer');
					overlay = document.getElementById('overlay');
					screenMiddle = {
						x : gameMargin.offsetWidth / (2 * gameScale),
						y : gameMargin.offsetHeight / (2 * gameScale)
					};
					setTimeout(function(){
						initialize('load stone sprite');
					}, 1);
					break;

				case 'load stone sprite':
					sprites.stone = new spriteSet('sprites/stone.sprite', function(){
						setTimeout(function(){
							initialize('load floor sprite');
						}, 1);
					});
					break;

				case 'load floor sprite':
					sprites.ground = new spriteSet('sprites/ground.sprite', function(){
						setTimeout(function(){
							initialize('load dungeon elements');
						}, 1);
					});
					break;

				case 'load dungeon elements':
					sprites.dungeonElements = new spriteSet('sprites/dungeonElements.sprite', function(){
						setTimeout(function(){
							initialize('load player sprite');
						}, 1);
					});
					break;

				case 'load player sprite':
					playerSpriteSet.load("sprites/player.sprite", function(){
						player.sprite = new spriteClass(this);
						player.sprite.setScale(gameScale);
						player.sprite.appendTo(playerLayer);
						player.sprite.setPosition(screenMiddle.x, screenMiddle.y, true);

						player.sprite.setFrame('front_idle');
						setTimeout(function(){initialize('load map');}, 0);
						
					});
					break;

				case 'load map':
					var mapIdx = maps.length;
					maps[mapIdx] = new mapBuilder();
					maps[mapIdx].buildDungeon({
						width : 30,
						height: 30,
						roomscale: .8,
						stairup: true,
						stairdown: true,
			//			startTexture: '<'
					});
					activeMap = maps[mapIdx];

					// quick random placement for now:
					activeMap.playerPos = activeMap.findTextureSpot('.');
					renderArea(activeMap);

					setTimeout(function(){initialize('initialize keyboard');}, 1);
					break;

				case 'initialize keyboard':
					// the functions used here are defined in keyboard.js
					initialize_keymap();
					loadDefaultMotionControls();
					document.onkeyup = keyupCall;
					document.onkeydown = keydownCall;
					setTimeout(function(){initialize('finish');}, 1);
					break;

				case 'finish':
					gameInterval = setInterval(playGame, 70);
			}
		}

		window.onload = function(){
			initialize();
		};

	</script>
</head>
<body>
	<div id="gameMargin">
		<div id="mapLayer" class="gameLayer">
		</div>
		<div id="unitsLayer" class="gameLayer">
		</div>
		<div id="playerLayer" class="gameLayer">
		</div>
		<div id="overlay" class="gameLayer">
		</div>
	</div>
</body>
</html>
