<!doctype html>
<html>
<head>
	<link href="https://fonts.googleapis.com/css?family=VT323" rel="stylesheet">
	<style type="text/css">
		* { margin: 0; padding: 0;}

		body, html{
			
			height: 100%;
			image-rendering: pixelated;
			image-rendering: -moz-crisp-edges;
			image-rendering: crisp-edges;
			background-color: #000;
		}

		#gameCanvas{
			position:absolute;
			width:100%;
			height:100%;
		}

		#overlay{
			font-size: 30px;
			font-family: 'VT323', monospace;
			position:absolute;
			width:100%;
			height:100%;
		}
		/*
		div.darkness{
			background-color: #000;
			position: absolute;
		}
		*/
	</style>
	<script type="text/javascript" src="kbListener.js"></script>
	<script type="text/javascript" src="generator.js"></script> 
	<script type="text/javascript" src="canvasSprite.js"></script>
	<script type="text/javascript" src="jquery.min.js"></script>
	<script type="text/javascript">
		/*
		Math.random = (function(){
			var seed = 2;
			return function() {
				var x = Math.sin(seed++) * 10000;
				return x - Math.floor(x);
			}
		})();
		*/

		var viewRange = {x : 0, y : 0};
		var motionControls = {};
		var playerSpriteSet = new spriteSet();
		var player;
		var gameScale = 6, cellSize = 12;
		var sprites = {};
		var maps = Array();
		var activeMap;
		var mapLayer;
		var context;
		var gameInterval; // <-- the animation interval object
		var walkSpeed = 3;
		var angSpeedRatio = {
			x : .70711, // 1/sqrt(2) <- the axis projection of a 45 degree unit vector
			y : .70711

			/*
			// these old values were used on an isometric map
			x : 0.866, // <- sin(pi / 3)
			y : 0.5 // <- cos(pi / 3)
			*/
		};
		var screenMiddle = {x: 0, y : 0};
		var player = (function(){
			var position = {x : 0, y : 0};
			return {
				direction : 'down',
				sprite : null,
				'position' : position,
				setMapPos : function(x, y){
					// our grid position on the map
					map.playerPos.x = x;
					map.playerPos.y = y;

					// our real position in the map
					this.position.x = cellSize * x;
					this.position.y = cellSize * y;
				},
				canWalkOn : function(posx, posy){
					return true;

					var roundX = Math.floor(posx / cellSize)
					var roundY = Math.floor(posy / cellSize)
					var map = activeMap.map;
					var rval = true;
					if(roundX < 0 || roundY < 0 || roundX >= map.length || roundY >= map[roundX].length){
						rval = false;
					}else if({'#' : 1}[map[roundX][roundY]] != undefined){
						rval = false;
					}
					return rval;
				},
				currentMapVal : function(){
					var map = activeMap.map;
					var pos = activeMap.playerPos;
					var rval;

					if(pos.x < 0 || pos.y < 0 || pos.x >= map.length || pos.y >= map[pos.x].length){
						rval = null;
					}else{
						rval = map[pos.x][pos.y];
					}
					return rval;


				}/*,
				currentItems : function(){
					rval = Array();
					if(activeMap.mappedItems[map.playerPos.x] != undefined){
						if(activeMap.mappedItems[map.playerPos.x][map.playerPos.y] != undefined){
							for(var n in activeMap.mappedItems[map.playerPos.x][map.playerPos.y]){
								rval = rval.concat(activeMap.mappedItems[map.playerPos.x][map.playerPos.y]);
							}
						}
					}
					return rval;


				}*/,
				move : function(dx, dy, noCollision){
					var i, xTally, yTally;
					var sgndx = Math.sign(dx);
					var absdx = Math.abs(dx);
					var sgndy = Math.sign(dy);
					var absdy = Math.abs(dy);

					if (absdx >= absdy){
						yTally = absdx >> 1;
						for(i = 0; i < absdx; i++){
							yTally += absdy;
							if (yTally >= absdx){
								yTally -= absdx;
								if(this.canWalkOn(this.position.x, this.position.y + sgndy)){
									this.position.y += sgndy;
								}
							}
							if(this.canWalkOn(this.position.x + sgndx, this.position.y)){
								this.position.x += sgndx;
							}
						}
					}else{
						xTally = absdy >> 1;
						for(i = 0; i < absdy; i++){
							xTally += absdx;
							if(xTally >= absdy){
								xTally -= absdy;
								if(this.canWalkOn(this.position.x + sgndx, this.position.y)){
									this.position.x += sgndx;
								}
							}
							if(this.canWalkOn(this.position.x, this.y + sgndy)){
								this.position.y += sgndy;
							}
						}
					}
					activeMap.playerPos = {
						x : Math.floor(this.position.x / cellSize),
						y : Math.floor(this.position.y / cellSize)
					}
				},
				currentSequence: null,
				currentEndFrame : null
			};
		})();

		function renderView(area){
			var randomKey;
			var tree1GreensSprite = new cSprite(sprites.tree1);
			tree1GreensSprite.setScale(gameScale);

			var tree1Sprite = new cSprite(sprites.tree1);
			tree1Sprite.setScale(gameScale);

			var grassSprite = new cSprite(sprites.grass);
			grassSprite.setScale(gameScale);

			var stoneSprite = new cSprite(sprites.stone);
			stoneSprite.setScale(gameScale);

			var groundSprite = new cSprite(sprites.ground);
			groundSprite.setScale(gameScale);

			var dungeonElementsSprite = new cSprite(sprites.dungeonElements);
			dungeonElementsSprite.setScale(gameScale);

			var x, y, mapX, mapY, drawX, drawY, n;
			
			context.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

			for(x = 0; x < viewRange.width; x++){
				mapX = area.playerPos.x + x - Math.floor(screenMiddle.x / (gameScale * cellSize));
				if(mapX < 0 || mapX > area.map.length - 1) continue;
				for(y = 0; y < viewRange.height; y++){
					mapY = area.playerPos.y + y - Math.floor(screenMiddle.y / (gameScale * cellSize));
					if(mapY < 0 || mapY > area.map[mapX].length - 1) continue;

					drawX = (x * cellSize) * gameScale;
					drawY = (y * cellSize) * gameScale;
			 
					/*
					// added for example.  this is where hidemap should be handled.  if the map is
					// hidden here, rather than drawing a frame, we'll simply draw a blurry black
					// blob.
					if(area.hideMap[x][y]){

					}
					*/
					switch(area.map[mapX][mapY]){
						case '.':
							randomKey = Math.sin(mapX + mapY * viewRange.width) * 10000;
							randomKey -= Math.floor(randomKey);

							groundSprite.rotate(Math.floor(randomKey * 4) * Math.PI / 2);
							groundSprite.drawRandomArea(context, drawX, drawY, cellSize, cellSize, randomKey);
							break;
						case '#':
							randomKey = Math.sin(mapX + mapY * viewRange.width) * 10000;
							randomKey -= Math.floor(randomKey);

							stoneSprite.setFrame(Math.floor(randomKey * 25));
							stoneSprite.draw(context, {x : drawX, y : drawY});
							break;
						case 'T':
							//grassSprite.rotate(Math.PI / 2);
							//grassSprite.drawRandomArea(mapLayer, drawX, drawY, cellSize, cellSize);
							//tree1GreensSprite.rotate(Math.random());
							//tree1GreensSprite.drawFrame(overheadLayer, 'greens', drawX, drawY);
							//tree1Sprite.drawFrame(unitsLayer, 'trunk', drawX, drawY);
							break;
						case '"':
							randomKey = Math.sin(mapX + mapY * viewRange.width) * 10000;
							randomKey -= Math.floor(randomKey);

							grassSprite.rotate(Math.PI / 2);
							grassSprite.drawRandomArea(context, drawX, drawY, cellSize, cellSize, randomKey);
							break;
						default:
							context.fillStyle = '#AAAA88';
							context.fillRect(drawX, drawY, cellSize * gameScale, cellSize * gameScale);
							continue;
					}
				}
			}

			player.sprite.draw(context, {x : screenMiddle.x, y : screenMiddle.y});
/*
			for(var itemName in area.items){
				for(n in area.items[itemName]){
					item = area.items[itemName][n];
					drawX = (item.x * cellSize - player.position.x) * gameScale;
					drawY = (item.y * cellSize - player.position.x) * gameScale;
					switch(item.content){
						case 'stairup':
							dungeonElementsSprite.setFrame('stairsUp');
							dungeonElementsSprite.draw(context, {x : drawX, y : drawY});
							break;
						case 'stairdown':
							dungeonElementsSprite.setFrame('stairsDown');
							dungeonElementsSprite.draw(context, {x : drawX, y : drawY});
							break;
					}
				}
			}
*/			


/*
			player.setMapPos(area.playerPos.x, area.playerPos.y);
*/
		}

		function writeText(x, y, text){
			$('<span></span>').html(text).css({position:'absolute', 'top': (y + 2), 'left': (x + 2), 'color' : '#000'}).appendTo($('#overlay'));
			$('<span></span>').html(text).css({position:'absolute', 'top': y, 'left': x, 'color' : '#EFE'}).appendTo($('#overlay'));
		}

		function playGame(){
			check_key_state();
			if(player.currentSequence != null){
				switch(player.currentSequence){
					case 'walkup': player.move(0, -walkSpeed); break;
					case 'walkdown': player.move(0, walkSpeed); break;
					case 'walkleft': player.move(-walkSpeed, 0); break;
					case 'walkright': player.move(walkSpeed, 0); break;
					case 'walkupleft': player.move(-angSpeedRatio.x * walkSpeed, -angSpeedRatio.y * walkSpeed ); break;
					case 'walkupright': player.move(angSpeedRatio.x * walkSpeed, -angSpeedRatio.y * walkSpeed ); break;
					case 'walkdownleft': player.move(-angSpeedRatio.x * walkSpeed, angSpeedRatio.y * walkSpeed); break;
					case 'walkdownright': player.move(angSpeedRatio.x * walkSpeed, angSpeedRatio.y * walkSpeed); break;
				}
				player.sprite.doSequenceStep();


			}
			renderView(activeMap);
		}

		function loadDefaultMotionControls(){
			motionControls = {
				up : [keyboard.KEYMAP['UP']],
				down: [keyboard.KEYMAP['DOWN']],
				left: [keyboard.KEYMAP['LEFT']],
				right: [keyboard.KEYMAP['RIGHT']],
				enter : [keyboard.KEYMAP['SHIFT'], keyboard.KEYMAP['.']],
				exit : [keyboard.KEYMAP['SHIFT'], keyboard.KEYMAP[',']],
				attack: [keyboard.KEYMAP['CTRL']],
				grab : [keyboard.KEYMAP[',']],
			};
		}

		function checkKeyControl(action){
			var rval, n;
			if(motionControls[action] != undefined){
				rval = true;
				for(n in motionControls[action]){
					rval &= keyboard.keyState[motionControls[action][n]] ? true : false;
				}
			}else{
				rval = false;
			}
			return rval;
		}

		function check_key_state(){
			var dirCombo = 0, n;
			var sequence = null;
			var endFrame = null;
			var fighting = checkKeyControl('attack');

			dirCombo += checkKeyControl('up') ? 1 : 0;
			dirCombo += checkKeyControl('down') ? 2 : 0;
			dirCombo += checkKeyControl('left') ? 4 : 0;
			dirCombo += checkKeyControl('right') ? 8 : 0;

			switch(dirCombo){
				case 1: // up
					sequence = 'walkup';
					endFrame = 'back_idle';
					player.direction = 'up';
					break;
				case 2: // down
					sequence = 'walkdown';
					endFrame = 'front_idle';
					player.direction = 'down';
					break;
				case 4: // left
					sequence = 'walkleft';
					endFrame = 'left_idle';
					player.direction = 'left';
					break;
				case 8: // right
					sequence = 'walkright';
					endFrame = 'right_idle';
					player.direction = 'right';
					break;
				case 5: // up/left
					sequence = 'walkupleft';
					endFrame = 'back_left_idle';
					player.direction = 'upleft';
					break;
				case 6: // down/left
					sequence = 'walkdownleft';
					endFrame = 'front_left_idle';
					player.direction = 'downleft';
					break;
				case 9: // up/right
					sequence = 'walkupright';
					endFrame = 'back_right_idle';
					player.direction = 'upright';
					break;
				case 10: // down/right
					sequence = 'walkdownright';
					endFrame = 'front_right_idle';
					player.direction = 'downright';
					break;
			}

			if(fighting){
				var endState = {
					'up' : 'back_idle',
					'down' : 'front_idle',
					'left' : 'left_idle',
					'right' : 'right_idle',
					'upleft' : 'back_left_idle',
					'upright' : 'back_right_idle',
					'downleft' : 'front_left_idle',
					'downright' : 'front_right_idle'
				}[player.direction];
				var newSequence = {
					'up' : 'attack_back',
					'down' : 'attack_front',
					'left' : 'attack_left',
					'right' : 'attack_right',
					'upleft' : 'attack_up_left',
					'upright' : 'attack_up_right',
					'downleft' : 'attack_down_left',
					'downright' : 'attack_down_right'
				}[player.direction];
				if(newSequence != undefined && newSequence != player.currentSequence){
					player.currentSequence = newSequence;
					player.sprite.startSequence(newSequence, {
						iterations: 1,
						method : 'manual',
						callback: function(){
							player.currentSequence = null;
							player.sprite.setFrame(endState);
						}
					});
				}
			}else{
				//var currentCellType = player.currentMapVal();
//				var currentItems = player.currentItems();

				if(sequence == null){
					if(player.currentSequence != null){
//						player.sprite.stopSequence(player.currentSequence);
						player.sprite.setFrame(player.currentEndFrame);
						player.currentSequence = null;
					}
					// this should be replaced with a call to a function that builds a menu of
					// actions available (e.g, "go down", "take food", "take weapon", etc.).  That
					// would be a mildly translucent menu that lits on another interface layer
					// above, perhaps to the bottom right of the player.  Each option in there
					// would have a keyboard shortcut(e.g. "pick up item [,]").  With an option not
					// to display those menus.
					/*
					for(n in currentItems){
						switch(currentItems[n].content){
							case 'stairup':
								if(checkKeyControl('exit')){
									useEntrance(currentItems[n]);
								}
								break;
							case 'stairdown':
								if(checkKeyControl('enter')){
									useEntrance(currentItems[n]);
								}
								break;
							default:
								console.log(currentItems[n].content);
						}
					}
					*/


				}else if(sequence != player.currentSequence){
					/*
					if(player.currentSequence != null){
						player.sprite.stopSequence(player.currentSequence);
					}
					*/
					player.currentEndFrame = endFrame;
					player.currentSequence = sequence;
					player.sprite.startSequence(sequence, {
						iterations: 0,
						method : 'manual',
						callback: function(){
							player.currentSequence = null;
							player.sprite.setFrame(endFrame);
						}
					});
				}
			}
		}
		function useEntrance(entrance){
			if(entrance.target == undefined){
				var mapIdx = maps.length;
				maps[mapIdx] = new mapBuilder();
				maps[mapIdx].build({
					category : 'dungeon',
					width : 30,
					height: 30,
					roomscale: .8,
					stairup: true,
					stairdown: true
				});
				entrance.target = maps[mapIdx];
			}

			switch(entrance.content){
				case 'stairup':
					entrance.target.playerPos = {
						x : entrance.target.items['stairdown'][0].x,
						y : entrance.target.items['stairdown'][0].y
					};
					if(entrance.target.items['stairdown'][0].target == undefined){
						entrance.target.items['stairdown'][0].target = activeMap;
					}
					break;
				case 'stairdown':
					entrance.target.playerPos = {
						x : entrance.target.items['stairup'][0].x,
						y : entrance.target.items['stairup'][0].y
					};
					if(entrance.target.items['stairdown'][0].target == undefined){
						entrance.target.items['stairup'][0].target = activeMap;
					}
					break;
			}
			activeMap = entrance.target;
			renderView(activeMap);
		}

		initialize = function(){

			this.spriteList = Array(
				{'name' : 'grass', 'file' : 'grass.sprite'},
				{'name' : 'tree1', 'file' : 'tree1.sprite'},
				{'name' : 'stone', 'file': 'stone.sprite'},
				{'name' : 'ground', 'file' : 'ground.sprite'},
				{'name' : 'dungeonElements', 'file' : 'dungeonElements.sprite'}
			);

		
			this.doStep = function(step){
				var dat;
				// pre-load any data we need to get the game started.
				// Note that using callbacks on this method prevents it from building a stack.
				// It also allows us to wait for each step to complete before calling the next
				// one.
				switch(step){
					case 'initialize':
						gameCanvas = document.getElementById('gameCanvas');
						gameCanvas.width = window.innerWidth;
						gameCanvas.height = window.innerHeight;

						screenMiddle = { x : gameCanvas.width >> 1, y : gameCanvas.height >> 1 };
						viewRange = {
							width: Math.ceil(gameCanvas.width / (gameScale * cellSize)),
							height: Math.ceil(gameCanvas.height / (gameScale * cellSize))
						}
						context = gameCanvas.getContext('2d');
						context.webkitImageSmoothingEnabled = false;
						context.mozImageSmoothingEnabled = false;
						context.imageSmoothingEnabled = false; /// future

						overlay = document.getElementById('overlay');
						
						writeText(5, 5, "DungeonCrawler v.0.0");
						setTimeout(function(){
							this.doStep('load sprites');
						}, 1);
						break;
					

					case 'load sprites':
						if(this.spriteList.length > 0){
							dat = this.spriteList.pop();
							sprites[dat.name] = new spriteSet('sprites/' + dat.file, function(){
								setTimeout(function(){
									this.doStep('load sprites');
								}, 1);
							});

						}else{
							this.doStep('load player sprite');
						}
						break;


					case 'load player sprite':
						playerSpriteSet.load("sprites/player.sprite", function(){
							player.sprite = new cSprite(this);
							player.sprite.setScale(gameScale);
							player.sprite.setPosition(screenMiddle.x, screenMiddle.y, true);

							player.sprite.setFrame('front_idle');
							setTimeout(function(){this.doStep('load map');}, 0);
						});
						break;

					case 'load map':
						var mapIdx = maps.length;
						maps[mapIdx] = new mapBuilder();
						maps[mapIdx].build({
							category : 'dungeon',
							width : 20,
							height: 20,
							roomscale: .2,
							//stairup: true,
							stairdown: true,
							//startTexture: '<'
						});
						activeMap = maps[mapIdx];

						// quick random placement for now:
						activeMap.playerPos = activeMap.findTextureSpot('.');
						player.position.x = Math.floor(cellSize * (activeMap.playerPos.x - .5));
						player.position.y = Math.floor(cellSize * (activeMap.playerPos.y - .5));

						renderView(activeMap);

						setTimeout(function(){this.doStep('initialize keyboard');}, 1);
						break;

					case 'initialize keyboard':
						// the functions used here are defined in keyboard.js
						keyboard = new kbListener();
						keyboard.listen();
						loadDefaultMotionControls();
						setTimeout(function(){this.doStep('finish');}, 1);
						break;

					case 'finish':

						gameInterval = setInterval(playGame, 70);
				}
			}
			this.doStep('initialize');
		};

		window.onload = function(){
			initialize();
		};

	</script>
</head>
<body>
	<canvas id="gameCanvas"></canvas>
	<div id="overlay"></div>
</body>
</html>
